# Java Collection Framework

> - Java에서 Collection(컬렉션)이란 데이터의 집합, 그룹을 의미합니다.
> - Java Collection Framework는 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합입니다. 
> - 컬렉션을 활용하면 데이터의 저장, 검색, 삭제, 정렬 등의 작업을 간편하게 수행할 수 있습니다.

## List, Set, Map 주요 특징 정리

| 인터페이스 | 구현체        | 순서 유지 | 중복 허용           | 기타 설명                                       |
|------------|----------------|------------|----------------------|------------------------------------------------|
| **List**   | ArrayList      | O          | O                    | 동적 배열 구조, 빠른 데이터 접근 가능                |
|            | LinkedList     | O          | O                    | 이중 연결 리스트, 빠른 삽입/삭제                       |
| **Set**    | HashSet        | X          | X                    | 해시 테이블 기반, 빠른 검색 및 삽입/삭제              |
|            | LinkedHashSet  | O          | X                    | 입력 순서 유지, 해시 테이블과 연결 리스트 결합          |
|            | TreeSet        | X          | X                    | 이진 탐색 트리 기반, 자동 정렬(오름차순)               |
| **Map**    | HashMap        | X          | `Key`: X / `Value`: O | 해시 테이블 기반, 빠른 검색 및 삽입/삭제                |
|            | LinkedHashMap  | O          | `Key`: X / `Value`: O | 입력 순서 유지, 빠른 검색 및 정렬                        |
|            | TreeMap        | X          | `Key`: X / `Value`: O | 이진 탐색 트리 기반, `Key`에 따라 자동 정렬              |


## Collection 주요 인터페이스

### 1. **List**
- **List**는 데이터의 저장 순서를 유지하며, 동일한 값을 여러 번 저장할 수 있는 인터페이스입니다.
- 저장된 데이터는 **인덱스**를 통해 접근 가능하며, 순차적인 데이터 처리가 용이합니다.
- **List** 인터페이스를 구현한 클래스들은 빠른 데이터 접근 및 검색을 지원하지만, 데이터의 크기가 커질수록 삽입 및 삭제 작업에 시간이 소요될 수 있습니다.

#### List 인터페이스의 주요 구현체
- **ArrayList**
  - 내부적으로 **배열**을 기반으로 하며, 단방향 포인터 구조로 이루어져 있습니다.
  - 데이터의 순차적인 접근(조회)이 매우 빠릅니다.
  - 크기가 고정된 배열과 달리 **동적 크기 조절**이 가능하지만, 배열의 크기를 재조정하는 작업은 비용이 발생할 수 있습니다.
  - 데이터 삽입 및 삭제는 느릴 수 있습니다(특히 중간에 삽입/삭제할 경우).

- **LinkedList**
  - **이중 연결 리스트** 구조를 기반으로 하며, 각 노드가 양방향으로 연결되어 있습니다.
  - 데이터의 삽입 및 삭제 작업이 매우 빠릅니다(중간에 삽입/삭제하는 경우에도 효율적).
  - 순차적인 데이터 접근 속도는 느릴 수 있으나, 리스트의 앞뒤로 삽입/삭제할 때 유리합니다.

### 2. **Set**
- **Set**은 데이터의 저장 순서를 유지하지 않으며, 중복된 데이터를 허용하지 않는 인터페이스입니다.
- 데이터는 유일해야 하며, 중복된 값은 자동으로 제거됩니다.
- 인덱스를 통한 데이터 접근이 불가능하므로, 데이터 조회 시에는 `Iterator`를 사용해야 합니다.
- 주로 데이터의 중복을 방지하거나 **유일한 값의 집합**을 유지해야 할 때 사용됩니다.

#### Set 인터페이스의 주요 구현체
- **HashSet**
  - 내부적으로 **해시 테이블**을 기반으로 하여 데이터를 저장합니다.
  - 데이터의 입력 순서를 보장하지 않으며, 빠른 검색 및 삽입/삭제가 가능합니다.
  - 데이터의 중복을 허용하지 않으며, `null` 값은 하나만 허용됩니다.

- **LinkedHashSet**
  - **HashSet**을 확장한 구조로, 데이터의 입력 순서를 유지합니다.
  - 순서가 중요한 경우 `LinkedHashSet`을 사용하며, 중복 데이터는 여전히 허용하지 않습니다.

- **TreeSet**
  - 내부적으로 **이진 탐색 트리**를 기반으로 데이터를 저장합니다.
  - 데이터는 자동으로 **오름차순 정렬**되며, 중복 데이터는 허용되지 않습니다.
  - 사용자 정의 객체의 경우 `Comparable` 인터페이스를 구현하여 정렬 기준을 설정할 수 있습니다.

### 3. **Map**
- **Map**은 **Key-Value** 쌍으로 데이터를 저장하는 인터페이스입니다.
- `Key`는 중복을 허용하지 않으며, 각 `Key`는 하나의 `Value`에 매핑됩니다.
- `Value`는 중복이 가능하며, 동일한 `Value`를 여러 `Key`와 연결할 수 있습니다.
- 인덱스가 없어 데이터 조회 시 `Iterator`나 `KeySet`, `EntrySet` 등을 사용합니다.
- 주로 **키를 기준으로 데이터를 검색**하거나 매핑된 데이터를 저장할 때 사용됩니다.

#### Map 인터페이스의 주요 구현체
- **HashMap**
  - **해시 테이블**을 기반으로 `Key-Value` 쌍을 저장합니다.
  - `Key`의 입력 순서를 보장하지 않으며, 빠른 검색 및 삽입/삭제가 가능합니다.
  - `null` 값을 `Key`와 `Value`로 사용할 수 있습니다.

- **LinkedHashMap**
  - **HashMap**을 확장한 구조로, `Key`의 입력 순서를 유지합니다.
  - 데이터가 삽입된 순서대로 접근이 필요할 때 유용하며, `null` 값도 지원합니다.

- **TreeMap**
  - **이진 탐색 트리**를 기반으로 `Key-Value`를 저장합니다.
  - `Key`는 자동으로 **오름차순 정렬**되며, 정렬 기준은 `Comparable`을 구현하여 사용자 정의가 가능합니다.
  - `Key`에 `null` 값을 허용하지 않습니다.

